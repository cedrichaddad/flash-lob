use std::error::Error;
use std::fs::File;
use std::path::PathBuf;
use clap::Parser;
use flash_lob::{Engine, Command, PlaceOrder, CancelOrder, OutputEvent, OrderType};
use flash_lob::coinbase::{TardisL3Row, CoinbaseMessage, DoneReason};

#[derive(Parser)]
#[command(author, version, about = "Flash-LOB Replay Validator")]
struct Args {
    /// Input CSV file (Tardis.dev L3 format)
    #[arg(short, long)]
    input: PathBuf,

    /// Max orders to replay
    #[arg(long)]
    limit: Option<usize>,
}

fn main() -> Result<(), Box<dyn Error>> {
    let args = Args::parse();
    
    println!("Initializing Replay Engine...");
    let mut engine = Engine::new(10_000_000); // Large capacity for replay
    
    let file = File::open(args.input)?;
    let mut rdr = csv::Reader::from_reader(file);
    
    let mut messages_processed = 0;
    let mut matches_validated = 0;
    let mut matches_missed = 0;
    
    println!("Starting replay from {:?}...", rdr);
    
    // We need to queue expected matches to verify them?
    // Or simpler: As we perform updates, we just check consistency.
    // Ideally, for exact replay: 
    // 1. We process 'received' -> PlaceOrder
    // 2. We capture engine output trades
    // 3. We look ahead in CSV for 'match' events? 
    // 
    // Strategy: We just feed input and print stats for now. 
    // Validation is complex because 'match' row in CSV might come *after* 'received' row.
    // But engine produces trade *immediately* upon 'PlaceOrder'.
    // So if engine output says "Trade", we expect a "match" row in CSV shortly.
    
    // Simplification for V1:
    // Just ensure no errors and final book state (if we had a snapshot to check against).
    // For "Correctness" demo: We will count how many explicit "match" messages from CSV 
    // align with our internal trades.
    
    let mut pending_trades = 0; // Trades engine generated but haven't seen 'match' in CSV yet?
    // Actually, usually CSV order is time-ordered.
    // 'received' (Taker) arrives.
    // 'match' (Trade) follows immediately.
    // So engine trades should correlate with 'match' rows.
    
    for result in rdr.deserialize() {
        if let Some(limit) = args.limit {
            if messages_processed >= limit {
                break;
            }
        }
        
        let row: TardisL3Row = result?;
        // Convert prices to cents (x100) or satoshis? Let's use x100 (cents) for USD pairs.
        let msg = row.to_message(100); 
        
        if let Some(msg) = msg {
            match msg {
                CoinbaseMessage::Received { order_id, side, price, qty } => {
                    // Place the order
                    // Default to Limit. If it crosses, it matches.
                    let cmd = Command::Place(PlaceOrder {
                        order_id,
                        user_id: 1, // Dummy user
                        side,
                        price, 
                        qty,
                        order_type: OrderType::Limit,
                    });
                    
                    let events = engine.process_command(cmd);
                    
                    // Count trades generated by engine
                    let engine_trades = events.iter().filter(|e| matches!(e, OutputEvent::Trade(_))).count();
                    pending_trades += engine_trades;
                },
                CoinbaseMessage::Done { order_id, reason, .. } => {
                    if reason == DoneReason::Canceled {
                        engine.process_command(Command::Cancel(CancelOrder { order_id }));
                    }
                },
                CoinbaseMessage::Match { .. } => {
                    // This is the exchange confirming a match.
                    // If our engine was correct, we should have generated a trade already.
                    if pending_trades > 0 {
                        matches_validated += 1;
                        pending_trades -= 1;
                    } else {
                        // We missed a trade? Or maybe timing issue?
                        matches_missed += 1;
                    }
                },
                _ => {}
            }
            messages_processed += 1;
        }
        
        if messages_processed % 100_000 == 0 {
            println!("Processed {} messages. Validated Matches: {}", messages_processed, matches_validated);
        }
    }
    
    println!("\n=== Replay Complete ===");
    println!("Total Messages: {}", messages_processed);
    println!("Matches Validated: {}", matches_validated);
    println!("Matches Missed (Lag/Diff): {}", matches_missed);
    println!("Remaining Pending Engine Trades: {}", pending_trades); 
    println!("Final Book Depth: {} bids, {} asks", engine.matcher.book.bids.len(), engine.matcher.book.asks.len());
    
    Ok(())
}
